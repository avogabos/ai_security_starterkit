# Few Shot Prompt testing for Security Analysis

Hello! Welcome to this walkthrough on how to use a simple few-shot prompt for security analysis using a popular LLM. If you are new to security automation with AI you're in the right place or curious of how to incorporate a few shot prompt into an existing workflow you are in the right place.

## ðŸ¤– What's the Purpose?
In the field of security operations, iteration is key. Before deploying AI-powered security solutions at scale, it's essential to test, iterate, and refine the tasks that we are automating. This Python script serves as a basic tool to help you do just that. Instead of a full-fledged application, think of this as your sandbox for rapid testing and iteration.

## ðŸš€ Quick Start
**Pre-requisites**
1. Python environment (3.x recommended).
2. OpenAI account with an API key.
3. Curiosity and an experimental mindset!

**Steps to Get Going**
API Key Setup: Ensure you've set up your OpenAI API key as an environment variable.

```bash
export OPENAI_API_KEY=YOUR_API_KEY
```

**Dependencies:** Install the openai Python library.

```bash
pip install openai
```

**Run & Experiment:** Execute the script and provide different test commands when prompted.

```bash
python YOUR_SCRIPT_NAME.py
```
**Analyze the Output:** Based on the provided few-shot prompt, the script will give you a JSON-formatted response detailing the analysis of the command.

## ðŸ“– Python Script
To better understand how the script let's look at the main components:

* **Environment Variable Setup:** This part fetches the API key you've set, which is essential for any communication with OpenAI's (or other LLMs) platform.
* **Reading the Document:** The function get_document_content is designed to read any markdown file that contains the desired few-shot prompt. For now, it reads from test_command_line_fs.md, but you could replace this with any markdown file of your choosing.
* **Interacting with OpenAI:** get_response_from_openai is the core function. It sends your test command along with the context (from the markdown file) to OpenAI and fetches a detailed analysis.

## ðŸ§  About the Few-Shot Prompt
The few-shot prompt is crucial. It's like teaching the AI how to approach the problem. For our purposes, the few shot prompt included in this example contains:

* Role & Objective: Directs the AI to think and act as a security expert.
* Analysis Context & Operating Environment: Gives the AI additional information about the environment.
* Security Tools and Platforms: Informs the AI of the tools at its disposal.

## ðŸ’¡ Tips for Effective Iteration
1. Refine the Prompt: Adjust and refine based on outputs. If the AI isn't understanding certain nuances, try making the prompt clearer.
2. Diverse Testing: The more diverse commands you test, the better you can gauge the model's accuracy - make sure that the few-shot prompt contains commands which you are likely to observe in your environment.
3. Feedback Loop: Keep track of the model's incorrect outputs and think about how to adjust your prompt to fix these - remember the more information you provide the model the better it can reason, however you will begin to experience diminishing returns if you overload your context window with information outside of the context of the task you are seeking to perform.

## ðŸ“ Example

**Example 1:**
```bash
Enter your test data: $encoded="SGVsbG8gV29ybGQ="; $decoded=$(echo $encoded | base64 --decode); $dir_name="./tmp_$(date +%N)"; mkdir $dir_name && cd $dir_name; $file_name="data_$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 13).txt"; echo $decoded > $file_name; cat $file_name | rev; rm -rf $dir_name;


Response from model:
 {
  "Summary": "The command is a series of tasks which base64 decodes an encoded string, dynamically create a temporary directory, create a random text file inside the directory, save the decoded string to the file, reverse the string contents, display it, and eventually delete the directory.",
  "Classification": "Benign",
  "Explanation": "This series of commands appears to be a script for a benign operation. The 'base64' command is used for decoding a base64 encoded string. '$dir_name' is a variable set to a directory name dynamically using the date command. 'mkdir' and 'cd' commands are used to create and change into said directory. '$file_name' variable is set dynamically to a file name including a random string generated by 'head /dev/urandom | tr -dc A-Za-z0-9 | head -c 13'. The 'echo' command writes the decoded string into the file. The 'cat' with 'rev' command reads and reverses the content of the file. Finally, 'rm -rf $dir_name' is used to remove the directory and its contents. While some individual commands could be misused in harmful ways, in this context they are being used for benign operations such as encoding/decoding strings, file creation, reading, and deletion.",
  "Recommendations": "N/A"
}```

**Example 2:**
```bash
Enter your test data: $t="R";$c="whoami.exe";schtasks /create /tn $t /tr $c /sc once /st 00:00 /ru SYSTEM;schtasks /run /tn $t;schtasks /delete /tn $t /f

Response from model:
 {
  "Summary": "This command creates a scheduled task to run 'whoami.exe' as SYSTEM, initiates the scheduled task, then deletes the task.",
  "Classification": "Malicious",
  "Explanation": "This is a series of 'schtasks' commands to create, run, and delete a task that will execute 'whoami.exe' as the SYSTEM user at a scheduled time, in this case, at '00:00'. The '/ru SYSTEM' option means the task runs with SYSTEM privileges, the highest level of permissions. 'whoami.exe' is a command-line utility that outputs the username of the user running the command; if run as SYSTEM, it signifies an escalation of privileges which is a common technique seen in attacks. The creation and subsequent deletion of the task after running could be an attempt to erase traces of the malicious activity.",
  "Recommendations": [
        "1. Document the observed malicious activity in 'Jira' and make sure to flag it as a major security incident. Include details such as the commands used, user, timestamps, and system.",
        "2. Isolate the compromised system to prevent any further malicious activities. Use Nessus or similar tools to scan the machine for any other potential threats or alterations.",
        "3. Use 'Splunk' and 'SentinelOne' to look for similar patterns of actions across the organization's environment, focusing on other occurrences of the 'schtasks' command with SYSTEM privileges."
  ]
}```

## ðŸŒ± Conclusion & Next Steps
You're all set to start iterating! Remember, the goal isn't just to get the model to do every aspect of your work, but to focus on discrete tasks that can be tailored to your specific circumstance. Once you're confident with the results you are recieving, you can then think about scaling or integrating it into larger security automation workflows.